digraph Mir_0_1280 {
    graph [fontname="Courier, monospace"];
    node [fontname="Courier, monospace"];
    edge [fontname="Courier, monospace"];
    label=<fn is_price_refresh_needed(_1: &amp;ReErased state::reserve::Reserve, _2: &amp;ReErased state::lending_market::LendingMarket, _3: i64) -&gt; bool<br align="left"/>let _4: u64;<br align="left"/>let mut _5: i64;<br align="left"/>let _6: u64;<br align="left"/>let _7: u64;<br align="left"/>let _8: u64;<br align="left"/>let mut _9: u8;<br align="left"/>let _10: u64;<br align="left"/>let mut _11: u64;<br align="left"/>let mut _12: u64;<br align="left"/>let mut _13: u64;<br align="left"/>let mut _14: (u64, bool);<br align="left"/>let mut _15: bool;<br align="left"/>let mut _16: u64;<br align="left"/>let mut _17: u64;<br align="left"/>let mut _18: u64;<br align="left"/>let mut _19: u64;<br align="left"/>debug reserve =&gt; _1;<br align="left"/>debug market =&gt; _2;<br align="left"/>debug current_ts =&gt; _3;<br align="left"/>debug current_ts =&gt; _4;<br align="left"/>debug price_last_updated_ts =&gt; _6;<br align="left"/>debug price_max_age =&gt; _7;<br align="left"/>debug price_refresh_trigger_to_max_age_pct =&gt; _8;<br align="left"/>debug price_refresh_trigger_to_max_age_secs =&gt; _10;<br align="left"/>>;
    bb0__0_1280 [shape="none", label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center" colspan="1">0</td></tr><tr><td align="left" balign="left">StorageLive(_4)<br/>StorageLive(_5)<br/>_5 = _3<br/>_4 = move _5 as u64 (IntToInt)<br/>StorageDead(_5)<br/>StorageLive(_6)<br/>_6 = (((*_1).5: state::reserve::ReserveLiquidity).6: u64)<br/>StorageLive(_7)<br/>_7 = ((((*_1).9: state::reserve::ReserveConfig).19: state::token_info::TokenInfo).3: u64)<br/>StorageLive(_8)<br/>StorageLive(_9)<br/>_9 = ((*_2).9: u8)<br/></td></tr><tr><td align="left">_8 = &lt;u8 as Into&lt;u64&gt;&gt;::into(move _9)</td></tr></table>>];
    bb1__0_1280 [shape="none", label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center" colspan="1">1</td></tr><tr><td align="left" balign="left">StorageDead(_9)<br/>StorageLive(_10)<br/>StorageLive(_11)<br/>StorageLive(_12)<br/>_12 = _7<br/>StorageLive(_13)<br/>_13 = _8<br/>_14 = CheckedMul(_12, _13)<br/></td></tr><tr><td align="left">assert(!move (_14.1: bool), &quot;attempt to compute `{} * {}`, which would overflow&quot;, move _12, move _13)</td></tr></table>>];
    bb2__0_1280 [shape="none", label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center" colspan="1">2</td></tr><tr><td align="left" balign="left">_11 = move (_14.0: u64)<br/>StorageDead(_13)<br/>StorageDead(_12)<br/>_15 = Eq(const 100_u64, const 0_u64)<br/></td></tr><tr><td align="left">assert(!move _15, &quot;attempt to divide `{}` by zero&quot;, _11)</td></tr></table>>];
    bb3__0_1280 [shape="none", label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center" colspan="1">3</td></tr><tr><td align="left" balign="left">_10 = Div(move _11, const 100_u64)<br/>StorageDead(_11)<br/>StorageLive(_16)<br/>StorageLive(_17)<br/>_17 = _4<br/>StorageLive(_18)<br/>_18 = _6<br/></td></tr><tr><td align="left">_16 = core::num::&lt;impl u64&gt;::saturating_sub(move _17, move _18)</td></tr></table>>];
    bb4__0_1280 [shape="none", label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center" colspan="1">4</td></tr><tr><td align="left" balign="left">StorageDead(_18)<br/>StorageDead(_17)<br/>StorageLive(_19)<br/>_19 = _10<br/>_0 = Ge(move _16, move _19)<br/>StorageDead(_19)<br/>StorageDead(_16)<br/>StorageDead(_10)<br/>StorageDead(_8)<br/>StorageDead(_7)<br/>StorageDead(_6)<br/>StorageDead(_4)<br/></td></tr><tr><td align="left">return</td></tr></table>>];
    bb0__0_1280 -> bb1__0_1280 [label="return"];
    bb1__0_1280 -> bb2__0_1280 [label="success"];
    bb2__0_1280 -> bb3__0_1280 [label="success"];
    bb3__0_1280 -> bb4__0_1280 [label="return"];
}
