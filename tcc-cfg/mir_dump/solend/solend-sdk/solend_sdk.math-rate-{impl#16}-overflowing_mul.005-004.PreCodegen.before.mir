// MIR for `rate::<impl at C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:587:3: 587:13>::overflowing_mul` before PreCodegen

fn rate::<impl at C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:587:3: 587:13>::overflowing_mul(_1: U128, _2: U128) -> (U128, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (math::rate::U128, bool);
    let _3: [u64; 4];
    let _7: ();
    let _8: ();
    let mut _9: bool;
    let _12: usize;
    let mut _13: usize;
    let mut _14: bool;
    let _15: ();
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let _19: {closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let mut _20: (u64, u64);
    let mut _21: u64;
    let _22: usize;
    let mut _23: usize;
    let mut _24: bool;
    let mut _25: u64;
    let _27: usize;
    let mut _28: usize;
    let mut _29: bool;
    let mut _32: (u64, u64);
    let mut _33: u128;
    let mut _34: u128;
    let mut _35: u64;
    let mut _36: u128;
    let mut _37: u64;
    let mut _38: (u128, bool);
    let _41: usize;
    let mut _42: (usize, bool);
    let mut _43: usize;
    let mut _44: bool;
    let mut _47: (u64, bool);
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: u64;
    let mut _51: u64;
    let _53: usize;
    let mut _54: usize;
    let mut _55: (usize, bool);
    let mut _56: (usize, bool);
    let mut _57: usize;
    let mut _58: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: bool;
    let mut _63: (u64, bool);
    let mut _66: (u64, bool);
    let mut _67: u64;
    let mut _68: u64;
    let mut _71: (u64, bool);
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: u64;
    let mut _75: bool;
    let mut _76: bool;
    let mut _77: bool;
    let _78: ();
    let mut _79: bool;
    let mut _80: bool;
    let mut _81: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let _82: {closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let mut _83: (u64, u64);
    let mut _84: u64;
    let _85: usize;
    let mut _86: usize;
    let mut _87: bool;
    let mut _88: u64;
    let _90: usize;
    let mut _91: usize;
    let mut _92: bool;
    let mut _95: (u64, u64);
    let mut _96: u128;
    let mut _97: u128;
    let mut _98: u64;
    let mut _99: u128;
    let mut _100: u64;
    let mut _101: (u128, bool);
    let _104: usize;
    let mut _105: (usize, bool);
    let mut _106: usize;
    let mut _107: bool;
    let mut _110: (u64, bool);
    let mut _111: u64;
    let mut _112: u64;
    let mut _113: u64;
    let mut _114: u64;
    let _116: usize;
    let mut _117: usize;
    let mut _118: (usize, bool);
    let mut _119: (usize, bool);
    let mut _120: usize;
    let mut _121: bool;
    let mut _123: u64;
    let mut _124: u64;
    let mut _125: bool;
    let mut _126: (u64, bool);
    let mut _129: (u64, bool);
    let mut _130: u64;
    let mut _131: u64;
    let mut _134: (u64, bool);
    let mut _135: u64;
    let mut _136: u64;
    let mut _137: u64;
    let mut _138: bool;
    let mut _139: bool;
    let mut _140: bool;
    let _141: ();
    let mut _142: bool;
    let _145: usize;
    let mut _146: usize;
    let mut _147: bool;
    let _148: ();
    let mut _149: bool;
    let mut _150: bool;
    let mut _151: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let _152: {closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let mut _153: (u64, u64);
    let mut _154: u64;
    let _155: usize;
    let mut _156: usize;
    let mut _157: bool;
    let mut _158: u64;
    let _160: usize;
    let mut _161: usize;
    let mut _162: bool;
    let mut _165: (u64, u64);
    let mut _166: u128;
    let mut _167: u128;
    let mut _168: u64;
    let mut _169: u128;
    let mut _170: u64;
    let mut _171: (u128, bool);
    let _174: usize;
    let mut _175: (usize, bool);
    let mut _176: usize;
    let mut _177: bool;
    let mut _180: (u64, bool);
    let mut _181: u64;
    let mut _182: u64;
    let mut _183: u64;
    let mut _184: u64;
    let _186: usize;
    let mut _187: usize;
    let mut _188: (usize, bool);
    let mut _189: (usize, bool);
    let mut _190: usize;
    let mut _191: bool;
    let mut _193: u64;
    let mut _194: u64;
    let mut _195: bool;
    let mut _196: (u64, bool);
    let mut _199: (u64, bool);
    let mut _200: u64;
    let mut _201: u64;
    let mut _204: (u64, bool);
    let mut _205: u64;
    let mut _206: u64;
    let mut _207: u64;
    let mut _208: bool;
    let mut _209: bool;
    let mut _210: bool;
    let _211: ();
    let mut _212: bool;
    let mut _213: bool;
    let mut _214: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let _215: {closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
    let mut _216: (u64, u64);
    let mut _217: u64;
    let _218: usize;
    let mut _219: usize;
    let mut _220: bool;
    let mut _221: u64;
    let _223: usize;
    let mut _224: usize;
    let mut _225: bool;
    let mut _228: (u64, u64);
    let mut _229: u128;
    let mut _230: u128;
    let mut _231: u64;
    let mut _232: u128;
    let mut _233: u64;
    let mut _234: (u128, bool);
    let _237: usize;
    let mut _238: (usize, bool);
    let mut _239: usize;
    let mut _240: bool;
    let mut _243: (u64, bool);
    let mut _244: u64;
    let mut _245: u64;
    let mut _246: u64;
    let mut _247: u64;
    let _249: usize;
    let mut _250: usize;
    let mut _251: (usize, bool);
    let mut _252: (usize, bool);
    let mut _253: usize;
    let mut _254: bool;
    let mut _256: u64;
    let mut _257: u64;
    let mut _258: bool;
    let mut _259: (u64, bool);
    let mut _262: (u64, bool);
    let mut _263: u64;
    let mut _264: u64;
    let mut _267: (u64, bool);
    let mut _268: u64;
    let mut _269: u64;
    let mut _270: u64;
    let mut _271: bool;
    let mut _272: bool;
    let mut _273: bool;
    let mut _275: [u64; 4];
    let mut _276: math::rate::U128;
    let mut _277: [u64; 2];
    let _278: usize;
    let mut _279: usize;
    let mut _280: bool;
    let mut _281: bool;
    let mut _282: &[u64; 2];
    let _283: &[u64; 2];
    let _284: usize;
    let mut _285: usize;
    let mut _286: bool;
    scope 1 {
        debug ret => _3;
        let _274: [[u64; 2]; 2];
        scope 49 {
            debug ret => _274;
        }
        scope 50 {
        }
    }
    scope 2 {
        let _4: &[u64; 2];
        scope 3 {
            debug me => _4;
            let _5: &[u64; 2];
            scope 4 {
                debug you => _5;
                let mut _6: [u64; 4];
                scope 5 {
                    debug ret => _6;
                    scope 6 {
                        let mut _10: u64;
                        let mut _143: u64;
                        scope 7 {
                            debug carry => _10;
                            let _11: u64;
                            scope 8 {
                                debug b => _11;
                                scope 9 {
                                    let _26: u64;
                                    let _89: u64;
                                    let mut _289: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
                                    let mut _290: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
                                    scope 10 {
                                        debug a => _26;
                                        let _30: u64;
                                        let _31: u64;
                                        scope 11 {
                                            debug hi => _30;
                                            debug low => _31;
                                            let _39: bool;
                                            let _40: &mut u64;
                                            scope 12 {
                                                debug overflow => _39;
                                                let _52: &mut u64;
                                                scope 15 {
                                                    debug existing_hi => _52;
                                                    let _59: u64;
                                                    scope 16 {
                                                        debug hi => _59;
                                                        let _64: u64;
                                                        let _65: bool;
                                                        scope 17 {
                                                            debug hi => _64;
                                                            debug o0 => _65;
                                                            let _69: u64;
                                                            let _70: bool;
                                                            scope 18 {
                                                                debug hi => _69;
                                                                debug o1 => _70;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            scope 13 {
                                                debug existing_low => _40;
                                                let _45: u64;
                                                let _46: bool;
                                                scope 14 {
                                                    debug low => _45;
                                                    debug o => _46;
                                                }
                                            }
                                        }
                                    }
                                    scope 19 {
                                        debug a => _89;
                                        let _93: u64;
                                        let _94: u64;
                                        scope 20 {
                                            debug hi => _93;
                                            debug low => _94;
                                            let _102: bool;
                                            let _103: &mut u64;
                                            scope 21 {
                                                debug overflow => _102;
                                                let _115: &mut u64;
                                                scope 24 {
                                                    debug existing_hi => _115;
                                                    let _122: u64;
                                                    scope 25 {
                                                        debug hi => _122;
                                                        let _127: u64;
                                                        let _128: bool;
                                                        scope 26 {
                                                            debug hi => _127;
                                                            debug o0 => _128;
                                                            let _132: u64;
                                                            let _133: bool;
                                                            scope 27 {
                                                                debug hi => _132;
                                                                debug o1 => _133;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            scope 22 {
                                                debug existing_low => _103;
                                                let _108: u64;
                                                let _109: bool;
                                                scope 23 {
                                                    debug low => _108;
                                                    debug o => _109;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        scope 28 {
                            debug carry => _143;
                            let _144: u64;
                            scope 29 {
                                debug b => _144;
                                scope 30 {
                                    let _159: u64;
                                    let _222: u64;
                                    let mut _287: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
                                    let mut _288: &{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73};
                                    scope 31 {
                                        debug a => _159;
                                        let _163: u64;
                                        let _164: u64;
                                        scope 32 {
                                            debug hi => _163;
                                            debug low => _164;
                                            let _172: bool;
                                            let _173: &mut u64;
                                            scope 33 {
                                                debug overflow => _172;
                                                let _185: &mut u64;
                                                scope 36 {
                                                    debug existing_hi => _185;
                                                    let _192: u64;
                                                    scope 37 {
                                                        debug hi => _192;
                                                        let _197: u64;
                                                        let _198: bool;
                                                        scope 38 {
                                                            debug hi => _197;
                                                            debug o0 => _198;
                                                            let _202: u64;
                                                            let _203: bool;
                                                            scope 39 {
                                                                debug hi => _202;
                                                                debug o1 => _203;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            scope 34 {
                                                debug existing_low => _173;
                                                let _178: u64;
                                                let _179: bool;
                                                scope 35 {
                                                    debug low => _178;
                                                    debug o => _179;
                                                }
                                            }
                                        }
                                    }
                                    scope 40 {
                                        debug a => _222;
                                        let _226: u64;
                                        let _227: u64;
                                        scope 41 {
                                            debug hi => _226;
                                            debug low => _227;
                                            let _235: bool;
                                            let _236: &mut u64;
                                            scope 42 {
                                                debug overflow => _235;
                                                let _248: &mut u64;
                                                scope 45 {
                                                    debug existing_hi => _248;
                                                    let _255: u64;
                                                    scope 46 {
                                                        debug hi => _255;
                                                        let _260: u64;
                                                        let _261: bool;
                                                        scope 47 {
                                                            debug hi => _260;
                                                            debug o0 => _261;
                                                            let _265: u64;
                                                            let _266: bool;
                                                            scope 48 {
                                                                debug hi => _265;
                                                                debug o1 => _266;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            scope 43 {
                                                debug existing_low => _236;
                                                let _241: u64;
                                                let _242: bool;
                                                scope 44 {
                                                    debug low => _241;
                                                    debug o => _242;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(_1.0: [u64; 2]);
        StorageLive(_5);
        _5 = &(_2.0: [u64; 2]);
        StorageLive(_6);
        _6 = [const 0_u64; 4];
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = Ge(const _, const 0_usize);
        switchInt(move _9) -> [0: bb43, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = const 0_u64;
        StorageLive(_11);
        StorageLive(_12);
        _12 = const _;
        _13 = Len((*_5));
        _14 = Lt(_12, _13);
        assert(move _14, "index out of bounds: the length is {} but the index is {}", move _13, _12) -> [success: bb2, unwind continue];
    }

    bb2: {
        _11 = (*_5)[_12];
        StorageDead(_12);
        StorageLive(_15);
        StorageLive(_16);
        _16 = Ge(const _, const 0_usize);
        switchInt(move _16) -> [0: bb21, otherwise: bb3];
    }

    bb3: {
        StorageLive(_17);
        StorageLive(_18);
        _290 = const _;
        _18 = &(*_290);
        StorageLive(_20);
        StorageLive(_21);
        StorageLive(_22);
        _22 = const _;
        _23 = Len((*_4));
        _24 = Lt(_22, _23);
        assert(move _24, "index out of bounds: the length is {} but the index is {}", move _23, _22) -> [success: bb4, unwind continue];
    }

    bb4: {
        _21 = (*_4)[_22];
        StorageLive(_25);
        _25 = _10;
        _20 = (move _21, move _25);
        _17 = <{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73} as Fn<(u64, u64)>>::call(move _18, move _20) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _17) -> [0: bb19, otherwise: bb6];
    }

    bb6: {
        StorageDead(_25);
        StorageDead(_22);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_26);
        StorageLive(_27);
        _27 = const _;
        _28 = Len((*_4));
        _29 = Lt(_27, _28);
        assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _27) -> [success: bb7, unwind continue];
    }

    bb7: {
        _26 = (*_4)[_27];
        StorageDead(_27);
        StorageLive(_32);
        StorageLive(_33);
        StorageLive(_34);
        StorageLive(_35);
        _35 = _26;
        _34 = move _35 as u128 (IntToInt);
        StorageDead(_35);
        StorageLive(_36);
        StorageLive(_37);
        _37 = _11;
        _36 = move _37 as u128 (IntToInt);
        StorageDead(_37);
        _38 = CheckedMul(_34, _36);
        assert(!move (_38.1: bool), "attempt to compute `{} * {}`, which would overflow", move _34, move _36) -> [success: bb8, unwind continue];
    }

    bb8: {
        _33 = move (_38.0: u128);
        StorageDead(_36);
        StorageDead(_34);
        _32 = U128::split_u128(move _33) -> [return: bb9, unwind continue];
    }

    bb9: {
        StorageDead(_33);
        StorageLive(_30);
        _30 = (_32.0: u64);
        StorageLive(_31);
        _31 = (_32.1: u64);
        StorageDead(_32);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _42 = CheckedAdd(const _, const _);
        assert(!move (_42.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb10, unwind continue];
    }

    bb10: {
        _41 = move (_42.0: usize);
        _43 = Len(_6);
        _44 = Lt(_41, _43);
        assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _41) -> [success: bb11, unwind continue];
    }

    bb11: {
        _40 = &mut _6[_41];
        StorageLive(_47);
        StorageLive(_48);
        _48 = _31;
        StorageLive(_49);
        _49 = (*_40);
        _47 = core::num::<impl u64>::overflowing_add(move _48, move _49) -> [return: bb12, unwind continue];
    }

    bb12: {
        StorageDead(_49);
        StorageDead(_48);
        StorageLive(_45);
        _45 = (_47.0: u64);
        StorageLive(_46);
        _46 = (_47.1: bool);
        StorageDead(_47);
        StorageLive(_50);
        _50 = _45;
        (*_40) = move _50;
        StorageDead(_50);
        _39 = _46;
        StorageDead(_46);
        StorageDead(_45);
        StorageDead(_41);
        StorageDead(_40);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        _55 = CheckedAdd(const _, const _);
        assert(!move (_55.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb13, unwind continue];
    }

    bb13: {
        _54 = move (_55.0: usize);
        _56 = CheckedAdd(_54, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", move _54, const 1_usize) -> [success: bb14, unwind continue];
    }

    bb14: {
        _53 = move (_56.0: usize);
        StorageDead(_54);
        _57 = Len(_6);
        _58 = Lt(_53, _57);
        assert(move _58, "index out of bounds: the length is {} but the index is {}", move _57, _53) -> [success: bb15, unwind continue];
    }

    bb15: {
        _52 = &mut _6[_53];
        StorageLive(_59);
        StorageLive(_60);
        _60 = _30;
        StorageLive(_61);
        StorageLive(_62);
        _62 = _39;
        _61 = move _62 as u64 (IntToInt);
        StorageDead(_62);
        _63 = CheckedAdd(_60, _61);
        assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", move _60, move _61) -> [success: bb16, unwind continue];
    }

    bb16: {
        _59 = move (_63.0: u64);
        StorageDead(_61);
        StorageDead(_60);
        StorageLive(_66);
        StorageLive(_67);
        _67 = _59;
        StorageLive(_68);
        _68 = _10;
        _66 = core::num::<impl u64>::overflowing_add(move _67, move _68) -> [return: bb17, unwind continue];
    }

    bb17: {
        StorageDead(_68);
        StorageDead(_67);
        StorageLive(_64);
        _64 = (_66.0: u64);
        StorageLive(_65);
        _65 = (_66.1: bool);
        StorageDead(_66);
        StorageLive(_71);
        StorageLive(_72);
        _72 = _64;
        StorageLive(_73);
        _73 = (*_52);
        _71 = core::num::<impl u64>::overflowing_add(move _72, move _73) -> [return: bb18, unwind continue];
    }

    bb18: {
        StorageDead(_73);
        StorageDead(_72);
        StorageLive(_69);
        _69 = (_71.0: u64);
        StorageLive(_70);
        _70 = (_71.1: bool);
        StorageDead(_71);
        StorageLive(_74);
        _74 = _69;
        (*_52) = move _74;
        StorageDead(_74);
        StorageLive(_75);
        StorageLive(_76);
        _76 = _65;
        StorageLive(_77);
        _77 = _70;
        _75 = BitOr(move _76, move _77);
        StorageDead(_77);
        StorageDead(_76);
        _51 = move _75 as u64 (IntToInt);
        StorageDead(_75);
        StorageDead(_70);
        StorageDead(_69);
        StorageDead(_65);
        StorageDead(_64);
        StorageDead(_59);
        StorageDead(_53);
        StorageDead(_52);
        _10 = move _51;
        _15 = const ();
        StorageDead(_51);
        StorageDead(_39);
        StorageDead(_31);
        StorageDead(_30);
        StorageDead(_26);
        goto -> bb20;
    }

    bb19: {
        StorageDead(_25);
        StorageDead(_22);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        _15 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_17);
        goto -> bb22;
    }

    bb21: {
        _15 = const ();
        goto -> bb22;
    }

    bb22: {
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_78);
        StorageLive(_79);
        _79 = Ge(const _, const 0_usize);
        switchInt(move _79) -> [0: bb41, otherwise: bb23];
    }

    bb23: {
        StorageLive(_80);
        StorageLive(_81);
        _289 = const _;
        _81 = &(*_289);
        StorageLive(_83);
        StorageLive(_84);
        StorageLive(_85);
        _85 = const _;
        _86 = Len((*_4));
        _87 = Lt(_85, _86);
        assert(move _87, "index out of bounds: the length is {} but the index is {}", move _86, _85) -> [success: bb24, unwind continue];
    }

    bb24: {
        _84 = (*_4)[_85];
        StorageLive(_88);
        _88 = _10;
        _83 = (move _84, move _88);
        _80 = <{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73} as Fn<(u64, u64)>>::call(move _81, move _83) -> [return: bb25, unwind continue];
    }

    bb25: {
        switchInt(move _80) -> [0: bb39, otherwise: bb26];
    }

    bb26: {
        StorageDead(_88);
        StorageDead(_85);
        StorageDead(_84);
        StorageDead(_83);
        StorageDead(_81);
        StorageLive(_89);
        StorageLive(_90);
        _90 = const _;
        _91 = Len((*_4));
        _92 = Lt(_90, _91);
        assert(move _92, "index out of bounds: the length is {} but the index is {}", move _91, _90) -> [success: bb27, unwind continue];
    }

    bb27: {
        _89 = (*_4)[_90];
        StorageDead(_90);
        StorageLive(_95);
        StorageLive(_96);
        StorageLive(_97);
        StorageLive(_98);
        _98 = _89;
        _97 = move _98 as u128 (IntToInt);
        StorageDead(_98);
        StorageLive(_99);
        StorageLive(_100);
        _100 = _11;
        _99 = move _100 as u128 (IntToInt);
        StorageDead(_100);
        _101 = CheckedMul(_97, _99);
        assert(!move (_101.1: bool), "attempt to compute `{} * {}`, which would overflow", move _97, move _99) -> [success: bb28, unwind continue];
    }

    bb28: {
        _96 = move (_101.0: u128);
        StorageDead(_99);
        StorageDead(_97);
        _95 = U128::split_u128(move _96) -> [return: bb29, unwind continue];
    }

    bb29: {
        StorageDead(_96);
        StorageLive(_93);
        _93 = (_95.0: u64);
        StorageLive(_94);
        _94 = (_95.1: u64);
        StorageDead(_95);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _105 = CheckedAdd(const _, const _);
        assert(!move (_105.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb30, unwind continue];
    }

    bb30: {
        _104 = move (_105.0: usize);
        _106 = Len(_6);
        _107 = Lt(_104, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _104) -> [success: bb31, unwind continue];
    }

    bb31: {
        _103 = &mut _6[_104];
        StorageLive(_110);
        StorageLive(_111);
        _111 = _94;
        StorageLive(_112);
        _112 = (*_103);
        _110 = core::num::<impl u64>::overflowing_add(move _111, move _112) -> [return: bb32, unwind continue];
    }

    bb32: {
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_108);
        _108 = (_110.0: u64);
        StorageLive(_109);
        _109 = (_110.1: bool);
        StorageDead(_110);
        StorageLive(_113);
        _113 = _108;
        (*_103) = move _113;
        StorageDead(_113);
        _102 = _109;
        StorageDead(_109);
        StorageDead(_108);
        StorageDead(_104);
        StorageDead(_103);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        StorageLive(_117);
        _118 = CheckedAdd(const _, const _);
        assert(!move (_118.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb33, unwind continue];
    }

    bb33: {
        _117 = move (_118.0: usize);
        _119 = CheckedAdd(_117, const 1_usize);
        assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", move _117, const 1_usize) -> [success: bb34, unwind continue];
    }

    bb34: {
        _116 = move (_119.0: usize);
        StorageDead(_117);
        _120 = Len(_6);
        _121 = Lt(_116, _120);
        assert(move _121, "index out of bounds: the length is {} but the index is {}", move _120, _116) -> [success: bb35, unwind continue];
    }

    bb35: {
        _115 = &mut _6[_116];
        StorageLive(_122);
        StorageLive(_123);
        _123 = _93;
        StorageLive(_124);
        StorageLive(_125);
        _125 = _102;
        _124 = move _125 as u64 (IntToInt);
        StorageDead(_125);
        _126 = CheckedAdd(_123, _124);
        assert(!move (_126.1: bool), "attempt to compute `{} + {}`, which would overflow", move _123, move _124) -> [success: bb36, unwind continue];
    }

    bb36: {
        _122 = move (_126.0: u64);
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_129);
        StorageLive(_130);
        _130 = _122;
        StorageLive(_131);
        _131 = _10;
        _129 = core::num::<impl u64>::overflowing_add(move _130, move _131) -> [return: bb37, unwind continue];
    }

    bb37: {
        StorageDead(_131);
        StorageDead(_130);
        StorageLive(_127);
        _127 = (_129.0: u64);
        StorageLive(_128);
        _128 = (_129.1: bool);
        StorageDead(_129);
        StorageLive(_134);
        StorageLive(_135);
        _135 = _127;
        StorageLive(_136);
        _136 = (*_115);
        _134 = core::num::<impl u64>::overflowing_add(move _135, move _136) -> [return: bb38, unwind continue];
    }

    bb38: {
        StorageDead(_136);
        StorageDead(_135);
        StorageLive(_132);
        _132 = (_134.0: u64);
        StorageLive(_133);
        _133 = (_134.1: bool);
        StorageDead(_134);
        StorageLive(_137);
        _137 = _132;
        (*_115) = move _137;
        StorageDead(_137);
        StorageLive(_138);
        StorageLive(_139);
        _139 = _128;
        StorageLive(_140);
        _140 = _133;
        _138 = BitOr(move _139, move _140);
        StorageDead(_140);
        StorageDead(_139);
        _114 = move _138 as u64 (IntToInt);
        StorageDead(_138);
        StorageDead(_133);
        StorageDead(_132);
        StorageDead(_128);
        StorageDead(_127);
        StorageDead(_122);
        StorageDead(_116);
        StorageDead(_115);
        _10 = move _114;
        _78 = const ();
        StorageDead(_114);
        StorageDead(_102);
        StorageDead(_94);
        StorageDead(_93);
        StorageDead(_89);
        goto -> bb40;
    }

    bb39: {
        StorageDead(_88);
        StorageDead(_85);
        StorageDead(_84);
        StorageDead(_83);
        StorageDead(_81);
        _78 = const ();
        goto -> bb40;
    }

    bb40: {
        StorageDead(_80);
        goto -> bb42;
    }

    bb41: {
        _78 = const ();
        goto -> bb42;
    }

    bb42: {
        StorageDead(_79);
        StorageDead(_78);
        _8 = const ();
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb44;
    }

    bb43: {
        _8 = const ();
        goto -> bb44;
    }

    bb44: {
        StorageDead(_9);
        StorageDead(_8);
        StorageLive(_141);
        StorageLive(_142);
        _142 = Ge(const _, const 0_usize);
        switchInt(move _142) -> [0: bb87, otherwise: bb45];
    }

    bb45: {
        StorageLive(_143);
        _143 = const 0_u64;
        StorageLive(_144);
        StorageLive(_145);
        _145 = const _;
        _146 = Len((*_5));
        _147 = Lt(_145, _146);
        assert(move _147, "index out of bounds: the length is {} but the index is {}", move _146, _145) -> [success: bb46, unwind continue];
    }

    bb46: {
        _144 = (*_5)[_145];
        StorageDead(_145);
        StorageLive(_148);
        StorageLive(_149);
        _149 = Ge(const _, const 0_usize);
        switchInt(move _149) -> [0: bb65, otherwise: bb47];
    }

    bb47: {
        StorageLive(_150);
        StorageLive(_151);
        _288 = const _;
        _151 = &(*_288);
        StorageLive(_153);
        StorageLive(_154);
        StorageLive(_155);
        _155 = const _;
        _156 = Len((*_4));
        _157 = Lt(_155, _156);
        assert(move _157, "index out of bounds: the length is {} but the index is {}", move _156, _155) -> [success: bb48, unwind continue];
    }

    bb48: {
        _154 = (*_4)[_155];
        StorageLive(_158);
        _158 = _143;
        _153 = (move _154, move _158);
        _150 = <{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73} as Fn<(u64, u64)>>::call(move _151, move _153) -> [return: bb49, unwind continue];
    }

    bb49: {
        switchInt(move _150) -> [0: bb63, otherwise: bb50];
    }

    bb50: {
        StorageDead(_158);
        StorageDead(_155);
        StorageDead(_154);
        StorageDead(_153);
        StorageDead(_151);
        StorageLive(_159);
        StorageLive(_160);
        _160 = const _;
        _161 = Len((*_4));
        _162 = Lt(_160, _161);
        assert(move _162, "index out of bounds: the length is {} but the index is {}", move _161, _160) -> [success: bb51, unwind continue];
    }

    bb51: {
        _159 = (*_4)[_160];
        StorageDead(_160);
        StorageLive(_165);
        StorageLive(_166);
        StorageLive(_167);
        StorageLive(_168);
        _168 = _159;
        _167 = move _168 as u128 (IntToInt);
        StorageDead(_168);
        StorageLive(_169);
        StorageLive(_170);
        _170 = _144;
        _169 = move _170 as u128 (IntToInt);
        StorageDead(_170);
        _171 = CheckedMul(_167, _169);
        assert(!move (_171.1: bool), "attempt to compute `{} * {}`, which would overflow", move _167, move _169) -> [success: bb52, unwind continue];
    }

    bb52: {
        _166 = move (_171.0: u128);
        StorageDead(_169);
        StorageDead(_167);
        _165 = U128::split_u128(move _166) -> [return: bb53, unwind continue];
    }

    bb53: {
        StorageDead(_166);
        StorageLive(_163);
        _163 = (_165.0: u64);
        StorageLive(_164);
        _164 = (_165.1: u64);
        StorageDead(_165);
        StorageLive(_172);
        StorageLive(_173);
        StorageLive(_174);
        _175 = CheckedAdd(const _, const _);
        assert(!move (_175.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb54, unwind continue];
    }

    bb54: {
        _174 = move (_175.0: usize);
        _176 = Len(_6);
        _177 = Lt(_174, _176);
        assert(move _177, "index out of bounds: the length is {} but the index is {}", move _176, _174) -> [success: bb55, unwind continue];
    }

    bb55: {
        _173 = &mut _6[_174];
        StorageLive(_180);
        StorageLive(_181);
        _181 = _164;
        StorageLive(_182);
        _182 = (*_173);
        _180 = core::num::<impl u64>::overflowing_add(move _181, move _182) -> [return: bb56, unwind continue];
    }

    bb56: {
        StorageDead(_182);
        StorageDead(_181);
        StorageLive(_178);
        _178 = (_180.0: u64);
        StorageLive(_179);
        _179 = (_180.1: bool);
        StorageDead(_180);
        StorageLive(_183);
        _183 = _178;
        (*_173) = move _183;
        StorageDead(_183);
        _172 = _179;
        StorageDead(_179);
        StorageDead(_178);
        StorageDead(_174);
        StorageDead(_173);
        StorageLive(_184);
        StorageLive(_185);
        StorageLive(_186);
        StorageLive(_187);
        _188 = CheckedAdd(const _, const _);
        assert(!move (_188.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb57, unwind continue];
    }

    bb57: {
        _187 = move (_188.0: usize);
        _189 = CheckedAdd(_187, const 1_usize);
        assert(!move (_189.1: bool), "attempt to compute `{} + {}`, which would overflow", move _187, const 1_usize) -> [success: bb58, unwind continue];
    }

    bb58: {
        _186 = move (_189.0: usize);
        StorageDead(_187);
        _190 = Len(_6);
        _191 = Lt(_186, _190);
        assert(move _191, "index out of bounds: the length is {} but the index is {}", move _190, _186) -> [success: bb59, unwind continue];
    }

    bb59: {
        _185 = &mut _6[_186];
        StorageLive(_192);
        StorageLive(_193);
        _193 = _163;
        StorageLive(_194);
        StorageLive(_195);
        _195 = _172;
        _194 = move _195 as u64 (IntToInt);
        StorageDead(_195);
        _196 = CheckedAdd(_193, _194);
        assert(!move (_196.1: bool), "attempt to compute `{} + {}`, which would overflow", move _193, move _194) -> [success: bb60, unwind continue];
    }

    bb60: {
        _192 = move (_196.0: u64);
        StorageDead(_194);
        StorageDead(_193);
        StorageLive(_199);
        StorageLive(_200);
        _200 = _192;
        StorageLive(_201);
        _201 = _143;
        _199 = core::num::<impl u64>::overflowing_add(move _200, move _201) -> [return: bb61, unwind continue];
    }

    bb61: {
        StorageDead(_201);
        StorageDead(_200);
        StorageLive(_197);
        _197 = (_199.0: u64);
        StorageLive(_198);
        _198 = (_199.1: bool);
        StorageDead(_199);
        StorageLive(_204);
        StorageLive(_205);
        _205 = _197;
        StorageLive(_206);
        _206 = (*_185);
        _204 = core::num::<impl u64>::overflowing_add(move _205, move _206) -> [return: bb62, unwind continue];
    }

    bb62: {
        StorageDead(_206);
        StorageDead(_205);
        StorageLive(_202);
        _202 = (_204.0: u64);
        StorageLive(_203);
        _203 = (_204.1: bool);
        StorageDead(_204);
        StorageLive(_207);
        _207 = _202;
        (*_185) = move _207;
        StorageDead(_207);
        StorageLive(_208);
        StorageLive(_209);
        _209 = _198;
        StorageLive(_210);
        _210 = _203;
        _208 = BitOr(move _209, move _210);
        StorageDead(_210);
        StorageDead(_209);
        _184 = move _208 as u64 (IntToInt);
        StorageDead(_208);
        StorageDead(_203);
        StorageDead(_202);
        StorageDead(_198);
        StorageDead(_197);
        StorageDead(_192);
        StorageDead(_186);
        StorageDead(_185);
        _143 = move _184;
        _148 = const ();
        StorageDead(_184);
        StorageDead(_172);
        StorageDead(_164);
        StorageDead(_163);
        StorageDead(_159);
        goto -> bb64;
    }

    bb63: {
        StorageDead(_158);
        StorageDead(_155);
        StorageDead(_154);
        StorageDead(_153);
        StorageDead(_151);
        _148 = const ();
        goto -> bb64;
    }

    bb64: {
        StorageDead(_150);
        goto -> bb66;
    }

    bb65: {
        _148 = const ();
        goto -> bb66;
    }

    bb66: {
        StorageDead(_149);
        StorageDead(_148);
        StorageLive(_211);
        StorageLive(_212);
        _212 = Ge(const _, const 0_usize);
        switchInt(move _212) -> [0: bb85, otherwise: bb67];
    }

    bb67: {
        StorageLive(_213);
        StorageLive(_214);
        _287 = const _;
        _214 = &(*_287);
        StorageLive(_216);
        StorageLive(_217);
        StorageLive(_218);
        _218 = const _;
        _219 = Len((*_4));
        _220 = Lt(_218, _219);
        assert(move _220, "index out of bounds: the length is {} but the index is {}", move _219, _218) -> [success: bb68, unwind continue];
    }

    bb68: {
        _217 = (*_4)[_218];
        StorageLive(_221);
        _221 = _143;
        _216 = (move _217, move _221);
        _213 = <{closure@C:\Users\Yellow Letter HQ\.cargo\registry\src\index.crates.io-6f17d22bba15001f\uint-0.9.1\src\uint.rs:270:67: 270:73} as Fn<(u64, u64)>>::call(move _214, move _216) -> [return: bb69, unwind continue];
    }

    bb69: {
        switchInt(move _213) -> [0: bb83, otherwise: bb70];
    }

    bb70: {
        StorageDead(_221);
        StorageDead(_218);
        StorageDead(_217);
        StorageDead(_216);
        StorageDead(_214);
        StorageLive(_222);
        StorageLive(_223);
        _223 = const _;
        _224 = Len((*_4));
        _225 = Lt(_223, _224);
        assert(move _225, "index out of bounds: the length is {} but the index is {}", move _224, _223) -> [success: bb71, unwind continue];
    }

    bb71: {
        _222 = (*_4)[_223];
        StorageDead(_223);
        StorageLive(_228);
        StorageLive(_229);
        StorageLive(_230);
        StorageLive(_231);
        _231 = _222;
        _230 = move _231 as u128 (IntToInt);
        StorageDead(_231);
        StorageLive(_232);
        StorageLive(_233);
        _233 = _144;
        _232 = move _233 as u128 (IntToInt);
        StorageDead(_233);
        _234 = CheckedMul(_230, _232);
        assert(!move (_234.1: bool), "attempt to compute `{} * {}`, which would overflow", move _230, move _232) -> [success: bb72, unwind continue];
    }

    bb72: {
        _229 = move (_234.0: u128);
        StorageDead(_232);
        StorageDead(_230);
        _228 = U128::split_u128(move _229) -> [return: bb73, unwind continue];
    }

    bb73: {
        StorageDead(_229);
        StorageLive(_226);
        _226 = (_228.0: u64);
        StorageLive(_227);
        _227 = (_228.1: u64);
        StorageDead(_228);
        StorageLive(_235);
        StorageLive(_236);
        StorageLive(_237);
        _238 = CheckedAdd(const _, const _);
        assert(!move (_238.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb74, unwind continue];
    }

    bb74: {
        _237 = move (_238.0: usize);
        _239 = Len(_6);
        _240 = Lt(_237, _239);
        assert(move _240, "index out of bounds: the length is {} but the index is {}", move _239, _237) -> [success: bb75, unwind continue];
    }

    bb75: {
        _236 = &mut _6[_237];
        StorageLive(_243);
        StorageLive(_244);
        _244 = _227;
        StorageLive(_245);
        _245 = (*_236);
        _243 = core::num::<impl u64>::overflowing_add(move _244, move _245) -> [return: bb76, unwind continue];
    }

    bb76: {
        StorageDead(_245);
        StorageDead(_244);
        StorageLive(_241);
        _241 = (_243.0: u64);
        StorageLive(_242);
        _242 = (_243.1: bool);
        StorageDead(_243);
        StorageLive(_246);
        _246 = _241;
        (*_236) = move _246;
        StorageDead(_246);
        _235 = _242;
        StorageDead(_242);
        StorageDead(_241);
        StorageDead(_237);
        StorageDead(_236);
        StorageLive(_247);
        StorageLive(_248);
        StorageLive(_249);
        StorageLive(_250);
        _251 = CheckedAdd(const _, const _);
        assert(!move (_251.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const _) -> [success: bb77, unwind continue];
    }

    bb77: {
        _250 = move (_251.0: usize);
        _252 = CheckedAdd(_250, const 1_usize);
        assert(!move (_252.1: bool), "attempt to compute `{} + {}`, which would overflow", move _250, const 1_usize) -> [success: bb78, unwind continue];
    }

    bb78: {
        _249 = move (_252.0: usize);
        StorageDead(_250);
        _253 = Len(_6);
        _254 = Lt(_249, _253);
        assert(move _254, "index out of bounds: the length is {} but the index is {}", move _253, _249) -> [success: bb79, unwind continue];
    }

    bb79: {
        _248 = &mut _6[_249];
        StorageLive(_255);
        StorageLive(_256);
        _256 = _226;
        StorageLive(_257);
        StorageLive(_258);
        _258 = _235;
        _257 = move _258 as u64 (IntToInt);
        StorageDead(_258);
        _259 = CheckedAdd(_256, _257);
        assert(!move (_259.1: bool), "attempt to compute `{} + {}`, which would overflow", move _256, move _257) -> [success: bb80, unwind continue];
    }

    bb80: {
        _255 = move (_259.0: u64);
        StorageDead(_257);
        StorageDead(_256);
        StorageLive(_262);
        StorageLive(_263);
        _263 = _255;
        StorageLive(_264);
        _264 = _143;
        _262 = core::num::<impl u64>::overflowing_add(move _263, move _264) -> [return: bb81, unwind continue];
    }

    bb81: {
        StorageDead(_264);
        StorageDead(_263);
        StorageLive(_260);
        _260 = (_262.0: u64);
        StorageLive(_261);
        _261 = (_262.1: bool);
        StorageDead(_262);
        StorageLive(_267);
        StorageLive(_268);
        _268 = _260;
        StorageLive(_269);
        _269 = (*_248);
        _267 = core::num::<impl u64>::overflowing_add(move _268, move _269) -> [return: bb82, unwind continue];
    }

    bb82: {
        StorageDead(_269);
        StorageDead(_268);
        StorageLive(_265);
        _265 = (_267.0: u64);
        StorageLive(_266);
        _266 = (_267.1: bool);
        StorageDead(_267);
        StorageLive(_270);
        _270 = _265;
        (*_248) = move _270;
        StorageDead(_270);
        StorageLive(_271);
        StorageLive(_272);
        _272 = _261;
        StorageLive(_273);
        _273 = _266;
        _271 = BitOr(move _272, move _273);
        StorageDead(_273);
        StorageDead(_272);
        _247 = move _271 as u64 (IntToInt);
        StorageDead(_271);
        StorageDead(_266);
        StorageDead(_265);
        StorageDead(_261);
        StorageDead(_260);
        StorageDead(_255);
        StorageDead(_249);
        StorageDead(_248);
        _143 = move _247;
        _211 = const ();
        StorageDead(_247);
        StorageDead(_235);
        StorageDead(_227);
        StorageDead(_226);
        StorageDead(_222);
        goto -> bb84;
    }

    bb83: {
        StorageDead(_221);
        StorageDead(_218);
        StorageDead(_217);
        StorageDead(_216);
        StorageDead(_214);
        _211 = const ();
        goto -> bb84;
    }

    bb84: {
        StorageDead(_213);
        goto -> bb86;
    }

    bb85: {
        _211 = const ();
        goto -> bb86;
    }

    bb86: {
        StorageDead(_212);
        StorageDead(_211);
        _141 = const ();
        StorageDead(_144);
        StorageDead(_143);
        goto -> bb88;
    }

    bb87: {
        _141 = const ();
        goto -> bb88;
    }

    bb88: {
        StorageDead(_142);
        StorageDead(_141);
        _7 = const ();
        StorageDead(_7);
        _3 = _6;
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_274);
        StorageLive(_275);
        _275 = _3;
        _274 = move _275 as [[u64; 2]; 2] (Transmute);
        StorageDead(_275);
        StorageLive(_276);
        StorageLive(_277);
        StorageLive(_278);
        _278 = const 0_usize;
        _279 = Len(_274);
        _280 = Lt(_278, _279);
        assert(move _280, "index out of bounds: the length is {} but the index is {}", move _279, _278) -> [success: bb89, unwind continue];
    }

    bb89: {
        _277 = _274[_278];
        _276 = U128(move _277);
        StorageDead(_277);
        StorageLive(_281);
        StorageLive(_282);
        StorageLive(_283);
        StorageLive(_284);
        _284 = const 1_usize;
        _285 = Len(_274);
        _286 = Lt(_284, _285);
        assert(move _286, "index out of bounds: the length is {} but the index is {}", move _285, _284) -> [success: bb90, unwind continue];
    }

    bb90: {
        _283 = &_274[_284];
        _282 = &(*_283);
        _281 = U128::overflowing_mul::any_nonzero(move _282) -> [return: bb91, unwind continue];
    }

    bb91: {
        StorageDead(_282);
        _0 = (move _276, move _281);
        StorageDead(_281);
        StorageDead(_276);
        StorageDead(_274);
        StorageDead(_3);
        StorageDead(_284);
        StorageDead(_283);
        StorageDead(_278);
        return;
    }
}
