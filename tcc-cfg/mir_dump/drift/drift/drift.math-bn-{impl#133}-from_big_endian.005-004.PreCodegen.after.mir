// MIR for `bn::<impl at /home/bitnami/.cargo/registry/src/index.crates.io-6f17d22bba15001f/uint-0.9.1/src/uint.rs:587:3: 587:13>::from_big_endian` after PreCodegen

fn bn::<impl at /home/bitnami/.cargo/registry/src/index.crates.io-6f17d22bba15001f/uint-0.9.1/src/uint.rs:587:3: 587:13>::from_big_endian(_1: &[u8]) -> U192 {
    debug slice => _1;
    let mut _0: math::bn::U192;
    let _2: ();
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: (usize, bool);
    let mut _6: usize;
    let mut _7: &[u8];
    let mut _8: !;
    let mut _9: [u8; 24];
    let _10: ();
    let mut _11: &mut [u8];
    let mut _12: &mut [u8];
    let mut _13: &mut [u8; 24];
    let mut _14: std::ops::Range<usize>;
    let mut _15: usize;
    let mut _16: usize;
    let mut _17: (usize, bool);
    let mut _18: usize;
    let mut _19: &[u8];
    let mut _20: (usize, bool);
    let mut _21: usize;
    let mut _22: (usize, bool);
    let mut _23: &[u8];
    let _24: &&[u8];
    let _26: ();
    let mut _27: std::ops::Range<usize>;
    let mut _28: std::ops::Range<usize>;
    let mut _30: ();
    let _31: ();
    let mut _32: std::option::Option<usize>;
    let mut _33: &mut std::ops::Range<usize>;
    let mut _34: &mut std::ops::Range<usize>;
    let mut _35: isize;
    let mut _36: !;
    let mut _38: u64;
    let mut _39: &[u8];
    let _40: &[u8];
    let _41: &[u8];
    let mut _42: &[u8; 24];
    let mut _43: std::ops::RangeFrom<usize>;
    let mut _44: usize;
    let mut _45: usize;
    let mut _46: (usize, bool);
    let _47: usize;
    let mut _48: usize;
    let mut _49: usize;
    let mut _50: (usize, bool);
    let mut _51: (usize, bool);
    let mut _52: usize;
    let mut _53: bool;
    let mut _54: [u64; 3];
    let mut _55: &[u8];
    scope 1 {
        debug padded => _9;
        let mut _25: [u64; 3];
        scope 2 {
            debug ret => _25;
            let mut _29: std::ops::Range<usize>;
            scope 3 {
                debug iter => _29;
                let _37: usize;
                scope 4 {
                    debug i => _37;
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _5 = CheckedMul(const 3_usize, const 8_usize);
        assert(!move (_5.1: bool), "attempt to compute `{} * {}`, which would overflow", const 3_usize, const 8_usize) -> [success: bb1, unwind continue];
    }

    bb1: {
        _4 = move (_5.0: usize);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        _6 = core::slice::<impl [u8]>::len(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        StorageDead(_7);
        _3 = Ge(move _4, move _6);
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        StorageDead(_4);
        _2 = const ();
        StorageDead(_3);
        StorageDead(_2);
        StorageLive(_9);
        _9 = [const 0_u8; 24];
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        StorageLive(_13);
        _13 = &mut _9;
        StorageLive(_14);
        StorageLive(_15);
        StorageLive(_16);
        _17 = CheckedMul(const 3_usize, const 8_usize);
        assert(!move (_17.1: bool), "attempt to compute `{} * {}`, which would overflow", const 3_usize, const 8_usize) -> [success: bb5, unwind continue];
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_4);
        StorageLive(_8);
        _8 = panic(const "assertion failed: 3 * 8 >= slice.len()") -> unwind continue;
    }

    bb5: {
        _16 = move (_17.0: usize);
        StorageLive(_18);
        StorageLive(_19);
        _19 = &(*_1);
        _18 = core::slice::<impl [u8]>::len(move _19) -> [return: bb6, unwind continue];
    }

    bb6: {
        StorageDead(_19);
        _20 = CheckedSub(_16, _18);
        assert(!move (_20.1: bool), "attempt to compute `{} - {}`, which would overflow", move _16, move _18) -> [success: bb7, unwind continue];
    }

    bb7: {
        _15 = move (_20.0: usize);
        StorageDead(_18);
        StorageDead(_16);
        StorageLive(_21);
        _22 = CheckedMul(const 3_usize, const 8_usize);
        assert(!move (_22.1: bool), "attempt to compute `{} * {}`, which would overflow", const 3_usize, const 8_usize) -> [success: bb8, unwind continue];
    }

    bb8: {
        _21 = move (_22.0: usize);
        _14 = std::ops::Range::<usize> { start: move _15, end: move _21 };
        StorageDead(_21);
        StorageDead(_15);
        _12 = <[u8; 24] as IndexMut<std::ops::Range<usize>>>::index_mut(move _13, move _14) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = &mut (*_12);
        StorageDead(_14);
        StorageDead(_13);
        StorageLive(_23);
        StorageLive(_24);
        _24 = &_1;
        _55 = deref_copy (*_24);
        _23 = &(*_55);
        _10 = core::slice::<impl [u8]>::copy_from_slice(move _11, move _23) -> [return: bb10, unwind continue];
    }

    bb10: {
        StorageDead(_23);
        StorageDead(_11);
        StorageDead(_24);
        StorageDead(_12);
        StorageDead(_10);
        StorageLive(_25);
        _25 = [const 0_u64; 3];
        StorageLive(_26);
        StorageLive(_27);
        StorageLive(_28);
        _28 = std::ops::Range::<usize> { start: const 0_usize, end: const 3_usize };
        _27 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _28) -> [return: bb11, unwind continue];
    }

    bb11: {
        StorageDead(_28);
        StorageLive(_29);
        _29 = move _27;
        goto -> bb12;
    }

    bb12: {
        StorageLive(_31);
        StorageLive(_32);
        StorageLive(_33);
        StorageLive(_34);
        _34 = &mut _29;
        _33 = &mut (*_34);
        _32 = <std::ops::Range<usize> as Iterator>::next(move _33) -> [return: bb13, unwind continue];
    }

    bb13: {
        StorageDead(_33);
        _35 = discriminant(_32);
        switchInt(move _35) -> [0: bb16, 1: bb14, otherwise: bb15];
    }

    bb14: {
        StorageLive(_37);
        _37 = ((_32 as Some).0: usize);
        StorageLive(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        _42 = &_9;
        StorageLive(_43);
        StorageLive(_44);
        StorageLive(_45);
        _45 = _37;
        _46 = CheckedMul(const 8_usize, _45);
        assert(!move (_46.1: bool), "attempt to compute `{} * {}`, which would overflow", const 8_usize, move _45) -> [success: bb17, unwind continue];
    }

    bb15: {
        unreachable;
    }

    bb16: {
        _26 = const ();
        StorageDead(_34);
        StorageDead(_32);
        StorageDead(_31);
        StorageDead(_29);
        StorageDead(_27);
        StorageDead(_26);
        StorageLive(_54);
        _54 = _25;
        _0 = U192(move _54);
        StorageDead(_54);
        StorageDead(_25);
        StorageDead(_9);
        return;
    }

    bb17: {
        _44 = move (_46.0: usize);
        StorageDead(_45);
        _43 = RangeFrom::<usize> { start: move _44 };
        StorageDead(_44);
        _41 = <[u8; 24] as Index<RangeFrom<usize>>>::index(move _42, move _43) -> [return: bb18, unwind continue];
    }

    bb18: {
        StorageDead(_43);
        StorageDead(_42);
        _40 = &(*_41);
        _39 = &(*_40);
        _38 = <BigEndian as ByteOrder>::read_u64(move _39) -> [return: bb19, unwind continue];
    }

    bb19: {
        StorageDead(_39);
        StorageLive(_47);
        StorageLive(_48);
        StorageLive(_49);
        _49 = _37;
        _50 = CheckedSub(const 3_usize, _49);
        assert(!move (_50.1: bool), "attempt to compute `{} - {}`, which would overflow", const 3_usize, move _49) -> [success: bb20, unwind continue];
    }

    bb20: {
        _48 = move (_50.0: usize);
        StorageDead(_49);
        _51 = CheckedSub(_48, const 1_usize);
        assert(!move (_51.1: bool), "attempt to compute `{} - {}`, which would overflow", move _48, const 1_usize) -> [success: bb21, unwind continue];
    }

    bb21: {
        _47 = move (_51.0: usize);
        StorageDead(_48);
        _52 = Len(_25);
        _53 = Lt(_47, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _47) -> [success: bb22, unwind continue];
    }

    bb22: {
        _25[_47] = move _38;
        StorageDead(_38);
        StorageDead(_47);
        StorageDead(_41);
        StorageDead(_40);
        _31 = const ();
        StorageDead(_37);
        StorageDead(_34);
        StorageDead(_32);
        StorageDead(_31);
        _30 = const ();
        goto -> bb12;
    }
}
